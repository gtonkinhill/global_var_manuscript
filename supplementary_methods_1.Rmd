---
title: "Suplementary methods"
author: "Gerry Tonkin-Hill"
date: "`r Sys.Date()`"
output: 
  html_document:
    fig_width: 12
    fig_height: 8
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8,
                      echo=FALSE, warning=FALSE, message=FALSE,
                      tidy=TRUE)
```


##Load libraries

```{r}
library(data.table)
library(dplyr)
library(ggfortify)
library(ggplot2)
library(Rtsne)
library(flashpcaR)
library(stringr)
library(starmie)
library(ggtree)
library(ape)
library(pheatmap)

cols <- c("#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a","#ffff99","#b15928","#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69","#fccde5","#d9d9d9","#bc80bd","#ccebc5","#ffed6f")
```



##Otu Analysis
First we need to relabel the reads of Tessema et al to include isolate information for clustering.
```{python, eval = FALSE}
from mungo.fasta import FastaReader

read_to_isolate={}
with open("./data/read_info.csv", 'rU') as infile:
  infile.next()
  for line in infile:
    line=line.strip().split(",")
    read_to_isolate[line[0]]=line[1]

with open("./processed_data/tessema2015_renamed.fas", 'w') as outfile:
  for h,s in FastaReader("./data/tessema2015.fas"):
    outfile.write(">"+read_to_isolate[h]+"."+h+"\n"+s+"\n")
```

We start by clustering the raw 454 reads along with the reads from Tessema et al using a python script that makes use of the Usearch software suite.
```{bash, eval = FALSE}
cat ./data/combined_all_454_noPOR.fasta ./processed_data/tessema2015_renamed.fas > ./processed_data/combined_454_tessema.fas

python ~/clusterDBLa/clusterDBLa.py \
  -o ./processed_data/ \
  -r ./processed_data/combined_454_tessema.fas \
  --cpu 20
```

###Binary Analysis

Now we can investigate the isolates based on shared DBLa sequence types.

```{r}
isolateInformation <- fread("./data/isolate_information.csv"
                            , header=TRUE
                            , data.table = FALSE)
#Add in country information
isolateInformation$Country <- unlist(lapply(isolateInformation$Location
                                            , function(x) {
                                              str_split(x,  "_", n=2)[[1]][[1]]}))

#Remove duplicate entries of isolates that have been sequenced more than once
isolateInformation <- isolateInformation[!duplicated(isolateInformation$Isolate),]

otuTable <- fread("./processed_data/combined_454_tessema_renamed_otuTable_binary.txt"
                  , data.table = FALSE
                  , header=TRUE)

otuMatrix <- as.matrix(otuTable[,2:ncol(otuTable)])
rownames(otuMatrix) <- otuTable$`#OTU ID`
```

We next perform some filtering. We exclude the lab isolates and only investigate isolates that were found to have more than 20 DBLa types. This was found to be a sensible thresholf on having adequetly sequences an isolates VAR repetoir. Furthermore as we are interested in the realtionship between isolates we exclude the singletons from the binary analysis.
```{r}
#Filter otus that only appear in one isolate and isolates with less than 20 types
MIN_ISOLATE_PER_OTU = 2
MIN_OTUS_PER_ISOLATE = 20
MAX_OTUS_PER_ISOLATE = Inf
otuMatrix <- otuMatrix[, colSums(otuMatrix) >= MIN_OTUS_PER_ISOLATE]
otuMatrix <- otuMatrix[, colSums(otuMatrix) <= MAX_OTUS_PER_ISOLATE]
otuMatrix <- otuMatrix[rowSums(otuMatrix) >= MIN_ISOLATE_PER_OTU, ]

#Remove lab isolates
otuMatrixNoLab <- otuMatrix[,!(colnames(otuMatrix) %in% c("3D7", "3D7xDD2", "DD2", "DD2xHB3", "HB3", "HB3xDD2"))]
```

###PCA
```{r}
otuMatrixNoLab_t <- t(otuMatrixNoLab)

flash_pca <- flashpca(otuMatrixNoLab_t
                      , stand="binom", method="eigen"
                      , ndim=50, mem="high")

pca_df <- data.frame(Isolate = rownames(otuMatrixNoLab_t)
                     , flash_pca$vectors[, 1:6]
                     , stringsAsFactors = FALSE)
pca_df <- merge(pca_df, isolateInformation, by.x='Isolate', by.y='Isolate'
                , all.x=TRUE)

#PCA plot
gg <- ggplot(pca_df, aes(X1, X2, colour=Country)) + geom_point() 
gg <- gg + scale_color_manual(values = cols[1:length(unique(pca_df$Country))])
gg <- gg + theme_bw()
gg
```

###TSNE
```{r}
tsne <- Rtsne(flash_pca$vectors, perplexity=15
              , check_duplicates=FALSE, pca=FALSE
              , max_iter=1000, dims = 2)

tsne_df <- data.frame(Isolate=rownames(otuMatrixNoLab_t)
                      , x=tsne$Y[,1], y=tsne$Y[,2]
                      , num_types =rowSums(otuMatrixNoLab_t)
                      , stringsAsFactors = FALSE)
tsne_df <- merge(tsne_df, isolateInformation, by.x='Isolate', by.y='Isolate'
                , all.x=TRUE)

gg <- ggplot(tsne_df, aes(x=x, y=y, color=Country)) + geom_point()
gg <- gg + scale_color_manual(values = cols[1:length(unique(pca_df$Country))])
gg <- gg + theme_bw()
gg
```

We can also colour by the number of types to investigate the impact of multiple infections
```{r}
gg <- ggplot(tsne_df, aes(x=x, y=y, color=Country, alpha=num_types)) + geom_point()
gg <- gg + scale_color_manual(values = cols[1:length(unique(pca_df$Country))])
gg <- gg + theme_bw()
gg
```

We can also investigate disease status.

```{r}
gg <- ggplot(tsne_df, aes(x=x, y=y, color=Disease_Status)) + geom_point()
gg <- gg + scale_color_manual(values = cols[1:length(unique(pca_df$Country))])
gg <- gg + theme_bw()
gg
```

Age doesn't appear to be an issue.

```{r}
gg <- ggplot(tsne_df, aes(x=x, y=y, color=Age)) + geom_point()
gg <- gg + scale_color_manual(values = cols[1:length(unique(pca_df$Country))])
gg <- gg + theme_bw()
gg
```

We can also investigate the most conserved DBLa types. First lets look at a histogram of the number of times each DBLa is seen in the global population.
```{r}
h <- hist(rowSums(otuMatrixNoLab), breaks=500, plot = FALSE)
plot(h$mids, h$counts, log="y")
abline(v=c(20,50), col='red')
```

This suggests that the majority of types are seen less than 20 times. We now take a closer look at those seen at least 20 times.
```{r}
majorTypeMatrix <- otuMatrixNoLab[rowSums(otuMatrixNoLab)>=20,]
col_annotations <- data.frame(Isolate = colnames(majorTypeMatrix),
                              stringsAsFactors = FALSE)
col_annotations <- merge(col_annotations, isolateInformation,
                         by.x="Isolate", by.y="Isolate",
                         all.x=TRUE)
rownames(col_annotations) <- col_annotations$Isolate
col_annotations <- col_annotations[, c("Isolate","Country")]
col_annotations <- col_annotations[order(col_annotations$Country),]
majorTypeMatrix <- majorTypeMatrix[, match(col_annotations$Isolate, colnames(majorTypeMatrix))]
col_annotations$Isolate <- NULL
pheatmap(majorTypeMatrix, cluster_cols = FALSE
         , annotation_col = col_annotations
         , show_rownames = FALSE)
```

There are also a number of types that are very conserved. We now look closer at those seen more than 50 times
```{r}
majorTypeMatrix <- otuMatrixNoLab[rowSums(otuMatrixNoLab)>=50,]
dim(majorTypeMatrix)
col_annotations <- data.frame(Isolate = colnames(majorTypeMatrix),
                              stringsAsFactors = FALSE)
col_annotations <- merge(col_annotations, isolateInformation,
                         by.x="Isolate", by.y="Isolate",
                         all.x=TRUE)
rownames(col_annotations) <- col_annotations$Isolate
col_annotations <- col_annotations[, c("Isolate","Country")]
col_annotations <- col_annotations[order(col_annotations$Country),]
majorTypeMatrix <- majorTypeMatrix[, match(col_annotations$Isolate, colnames(majorTypeMatrix))]
col_annotations$Isolate <- NULL
pheatmap(majorTypeMatrix, cluster_cols = FALSE
         , annotation_col = col_annotations
         , show_rownames = FALSE)

write.table(rownames(majorTypeMatrix), file="./processed_data/majorTypesGE50.txt"
            , quote = FALSE
            , row.names = FALSE
            , col.names = FALSE)
```

#Run Admixture
Set up the required input file
```{r, eval=FALSE}
admixOut <- data.frame(family=rownames(otuMatrixNoLab_t),
                       individual=rownames(otuMatrixNoLab_t),
                       paternalId=rep(0, nrow(otuMatrixNoLab_t)),
                       maternalId=rep(0, nrow(otuMatrixNoLab_t)),
                       sex=rep(0, nrow(otuMatrixNoLab_t)),
                       phenotype=rep(-9, nrow(otuMatrixNoLab_t)))
admixOut <- cbind(admixOut, apply(otuMatrixNoLab_t, 2, function(x) x+1))
write.table(admixOut, file="./processed_data/admixture_input.ped"
            , quote=FALSE, sep=" "
            , row.names = FALSE, col.names=FALSE)
```

Run Admixture v1.3 for different K
```{bash, eval=FALSE}
cd ./processed_data/
for K in {1..10};
do
admixture -s 12345 -j20 --cv ./admixture_input.ped $K | tee log${K}.out;
done
cd ..
```

Investigate the output of Admixture. First we need to load in the results.
```{r}
q_files <- Sys.glob("./processed_data/*.Q")
p_files <- Sys.glob("./processed_data/*.P")
log_files <- Sys.glob("./processed_data/log*.out")

admix <- admixList(
  mapply(loadAdmixture, q_files, p_files, log_files, SIMPLIFY = FALSE)
)

populations <- data.frame(Isolate=rownames(otuMatrixNoLab_t),
                          stringsAsFactors = FALSE)
populations <- merge(populations, isolateInformation,
                     by.x="Isolate", by.y="Isolate", all.x=TRUE)
populations <- populations[,c("Isolate", "Country")]
populations <- populations[match(rownames(otuMatrixNoLab_t), populations$Isolate),]
populations$Isolate <- 1:nrow(populations)
```

A quick look at the outcome of the cross validation method.
```{r}
bestK(admix)
```

This indicates that with two hidden populations we produce the smallest cross validation error. This split is consistent with the split between the African and non-African isolates. The large seperation between Africa and non-Africa is consistent with what has been seen in non-VAR population structure analyses and is also usually observed in analyses of human population structure. Lets look at this split.

```{r}
t <- getQ(admix[unlist(lapply(admix,getK))==2][[1]])
rownames(t) <- 1:nrow(t)
plotBar(t, populations = populations)
```

It is also worth taking a look at the K from 1 to 10
```{r}
plotMultiK(admix[order(unlist(lapply(admix,getK)))], populations)
```

The small dip in the cross-validation error at K=6 appears to correspond with Admixture infering different hidden populations for the three African countries. At K=6 Iran is also distinct. For all K PNG does is not seperated from the African background cluster. This could be because of the different experimental method used in obtaining the PNG isolates.

We now take a closer look at the model with 6 underlying populations.
```{r}
t <- getQ(admix[unlist(lapply(admix,getK))==6][[1]])
rownames(t) <- 1:nrow(t)
plotBar(t, populations = populations)
```

Finally it is worth looking closer at a model with 10 underlying populations. That is the same number as the real number of countries present.

```{r}
t <- getQ(admix[unlist(lapply(admix,getK))==10][[1]])
rownames(t) <- 1:nrow(t)
plotBar(t, populations = populations)
```

A notable difference between K=6 and K=10 is that for K=6 Columbia appears to be very much within the African background cluster 2 whilst for K=10 cluster 7 indicates that Columbia is distinct from the vast majority of African isolates.

It should be noted that these mixtures are built off of the binary dataset which ignores any relationship between DBLa types that are only present once. Consequently, the JHMM model approach is more appropriate.

##RAxML
First we need to produce a binary fasta file
```{r, eval=FALSE}
text=ggplot2:::interleave(paste(">", rownames(otuMatrixNoLab_t), sep=""),
                          apply(otuMatrixNoLab_t, 1 , paste , collapse = "" ))
writeLines(text, con="./processed_data/DBLa_binary.fasta",
           sep="\n")
```

Now we can run RAxML

```{bash, eval=FALSE}
cd ./processed_data/
~/standard-RAxML-8.2.8/raxmlHPC-PTHREADS -m BINCAT -p 12345 -s DBLa_binary.fasta -n raxmlTree_T1 -T 20 | tee raxml.log
cd ..
```

We can now look at the output of RAxML.
```{r}
raxml <- read.tree("./processed_data/RAxML_result.raxmlTree_T1")

groupInfo <- isolateInformation %>% group_by(Country) %>%
  do(taxa_list = .$Isolate)
groupInfo <- groupInfo[!(groupInfo$Country %in% c("3D7", "3D7xDD2", "DD2", "DD2xHB3", "HB3", "HB3xDD2")),]

groups <- lapply(groupInfo$taxa_list, as.vector)
names(groups) <- groupInfo$Country
raxml <- groupOTU(raxml, groups)

gg <- ggtree(raxml, aes(color=group, label=node)
             , size=0.3, branch.length = "none", layout="circular")
gg <- gg + scale_color_manual(values=cols,
                              labels=names(groups)) +
  theme(legend.position="right")
gg
```

Lets check quickly how the Ugandan samples have clustered (doesnt appear interesting, do I include this?)
```{r}
raxml <- read.tree("./processed_data/RAxML_result.raxmlTree_T1")

tempInfo <- isolateInformation
tempInfo$Location[!grepl("Uganda", tempInfo$Location)] <- "Other"

groupInfo <- tempInfo %>% group_by(Location) %>%
  do(taxa_list = .$Isolate)
groupInfo <- groupInfo[!(groupInfo$Location %in% c("3D7", "3D7xDD2", "DD2", "DD2xHB3", "HB3", "HB3xDD2")),]

groups <- lapply(groupInfo$taxa_list, as.vector)
names(groups) <- groupInfo$Location
raxml <- groupOTU(raxml, groups)

gg <- ggtree(raxml, aes(color=group, label=node)
             , size=0.3, branch.length = "none", layout="circular")
gg <- gg + scale_color_manual(values=cols,
                              labels=names(groups)) +
  theme(legend.position="right")
gg
```

##Alignment free comparison with FFP

First we need to split the sequences into seperate fasta files for each isolate
```{bash, eval=FALSE}
mkdir ffp_data
cd ffp_data
cp ../processed_data/combined_454_tessema.fas ./
cd ..
```

```{python, eval=FALSE}
from mungo.fasta import FastaReader
from collections import defaultdict

isolates = defaultdict(list)

for h,s in FastaReader("./processed_data/combined_454_tessema.fas"):
  isolates[h.split(".")[0]].append((h,s))

for iso in isolates:
  with open("./processed_data/"+iso+".fasta",'w') as outfile:
    for s in isolates[iso]:
      outfile.write(">"+s[0]+"\n"+s[1]+"\n")
```

We would now like to decide on an appropriate choice for the l-mer length. To investigate this we use the centroids after clustering the 3D7 isolate reads as a reference.
```{bash, eval=FALSE}
cd ffp_data
python ../scripts/clusterDBLa.py -o ./ -r 3D7.fasta

#Construct a word usage (vocabulary) profile
ffpvprof -e 40 -f 2 3D7_renamed_centroids.fasta > ../processed_data/ffp_word_usage.txt

#Construct a relative entropy profile
ffpreprof -e 40 3D7_renamed_centroids.fasta > ../processed_data/ffp_entropy_profile.txt

#We no longer need the lab isolates and can remove them
rm *3D7*.fasta
rm *DD2*.fasta
rm *HB3*.fasta

cd ..
```

We can now attempt to choose an appropriate value of l. First let look at word usage to get an idea of a lower bound.
```{r}
word_usage <- fread("./processed_data/ffp_word_usage.txt",
                    data.table = FALSE)
plot(word_usage)
```

```{r}
entropy <- fread("./processed_data/ffp_entropy_profile.txt",
                    data.table = FALSE)
plot(entropy)
```

Thus a choice of l=20 appears to be appropriate.

We can now run a script to calculate the ffp distance matrix. The original ffp script from xxx generated segment faults when we attempted to use it.
```{bash, eval=FALSE}
python ./scripts/ffp.py --kmer_length 20 --out ./processed_data/ffp_distance_matrix.phylip --seq ./processed_data/combined_454_tessema.fas --verbose
```

##Session Information
```{r}
sessionInfo()
```
